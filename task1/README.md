**Задача**: Для каждого кадра с `timestamps1` найти индекс соответствующего кадра в `timestamps2`, где разность `abs(timestamps1[i] - timestamps2[j])` минимальна.

## Реализованные алгоритмы

### 1. Two-Pointer Algorithm (`match_timestamps`)
- **Сложность**: O(n + m)
- **Особенности**: Последовательный алгоритм с двумя указателями
- **Оптимизация**: JIT-компиляция через `@njit`

### 2. Parallel Binary Search (`match_timestamps_searchsorted`)
- **Сложность**: O(n log m)
- **Особенности**: Параллельный бинарный поиск
- **Оптимизация**: JIT-компиляция + параллелизм через `@njit(parallel=True)` и `prange`

## Результаты бенчмарков

| Сценарий | Dataset | searchsorted | two-pointer | Speedup |
|----------|---------|--------------|-------------|---------|
| 10 min, 30fps | 18K / 12K | 0.000134s | 0.000208s | 1.55x |
| 1 hour, 30fps | 108K / 102K | 0.001135s | 0.001740s | 1.53x |
| 2 hours, 30fps | 216K / 210K | 0.002219s | 0.003457s | 1.56x |
| 3 hours, 30fps | 324K / 318K | 0.002384s | 0.005686s | 2.38x |
| 2 hours, 60fps | 432K / 420K | 0.003415s | 0.006969s | 2.04x |
| 2 hours, 30+60fps | 216K / 420K | 0.001626s | 0.004300s | 2.64x |

### Выводы

- **Параллельный алгоритм** (`match_timestamps_searchsorted`) показывает **в 1.5–2.5 раза лучшую производительность** на больших объёмах данных
- Оба алгоритма эффективно обрабатывают данные за 2–3 часа видео
- При увеличении размера данных преимущество параллелизации растет
